# File Edit Callbacks — Design Discussion

## Phase A: Use Cases

### Problem Statement
The AI repeatedly performs the same manual verification loops after file edits (cargo check, lint, format, etc.). Callbacks would automate this feedback loop, giving the AI immediate results without manual intervention.

### Primary Use Cases Identified
1. **Build verification** — auto-check after code edits (cargo check, tsc, go build, etc.)
2. **Code quality gates** — auto-lint, complexity checks, file length checks, folder size checks
3. **Artifact generation** — edit source → regenerate output (PDF from python, LaTeX build, YAML→output). The goal is the side effect, not pass/fail.
4. **Auto-formatting / auto-fix** — edit code → auto-format (rustfmt, prettier, black). Modifies the edited file itself.
5. **Any project-specific post-edit action** — the system must be general-purpose

### Key Insight: All archetypes are just "run a bash script"
The TUI doesn't need to distinguish between validation, generation, or mutation callbacks. They're all the same: run a script, capture exit code + output, report back. The script decides what to do. This keeps the TUI implementation simple and project-agnostic.

### Auto-formatting circularity is a non-issue
When a formatting callback modifies a file the AI just edited, the file panel auto-refreshes (dynamic panels), and the callback result notification tells the AI what happened. The AI sees the updated file on its next turn. No special handling needed.

### Example use cases beyond programming (for inspiration — project configuration, not TUI code)
These illustrate that callbacks are really a **general event system** where file edits are the trigger:
- **Notification/Alert**: edit calendar.ics → send desktop notification; edit deploy config → Slack webhook
- **Sync/Deploy**: edit config.yaml → kubectl apply; edit HTML → rsync to server
- **Data Pipeline**: edit SQL query → re-run query → save results.csv
- **Doc Generation**: edit source → re-generate API docs (rustdoc, typedoc, sphinx)
- **Validation (non-code)**: edit Dockerfile → hadolint; edit Terraform → terraform validate
- **Scoped Testing**: edit foo.rs → cargo test only that module (using $CP_CHANGED_FILES)

All of these are just bash scripts from the TUI's perspective. The intelligence lives in the scripts, not the TUI.

### Key Constraints (from discussion)
- **Project-agnostic**: no hardcoded language support. User configures callbacks per project. Language-specific modules may come later, but the callback system itself must be generic.
- **AI edits only**: callbacks fire on `Edit` / `Write` tool calls, NOT on external file changes (vim, IDE, etc.)
- **Immediate feedback to LLM**: results must flow back to the AI so it can course-correct without manual check cycles
- **"Very nice to have"**: not solving a critical pain point, but eliminating repetitive manual verification loops

### Design Decisions (from discussion)

**Granularity: Named rules with patterns**
- Each callback is a named rule with a pattern (gitignore-like or regex) identifying matched files
- Patterns are positive-match (opposite of gitignore: identifies files that DO trigger the callback)
- Example: rule "rust-check" matches `*.rs`, rule "pdf-gen" matches `seeds/*.yaml`

**Batching: Per-batch, not per-edit**
- If AI makes 5 parallel Edit calls, callback fires ONCE after the batch completes
- Collects all changed files, checks which callbacks match any of them

**Blocking vs Non-blocking (per callback)**
- **Blocking callbacks**: result injected directly into the Edit/Write tool result. Always has a max timeout. If callback fails, file edit still succeeds but tool result shows callback failure.
- **Non-blocking callbacks**: tool result says "Callback Cx activated in background, will notify on completion." Uses the watcher→notification→spine pipeline (same as console_watch/coucou). Watchers visible in Spine panel.

**Configuration: AI via tool**
- AI can register/modify callbacks at runtime via a tool (e.g. `callback_register`)
- No config file required (though could be added later)

**Multi-match: all matching callbacks fire**
- A single edit can trigger multiple callbacks (e.g. `*.rs` matches both "rust-check" and "line-count")

**Persistence: config-level, with worker-level activation**
- Callback definitions stored at config level (persist across sessions, shared across workers)
- Individual workers can activate/deactivate callbacks for themselves (stored worker-level)

### Remaining Open Questions (Phase A)
- Should the AI be prompted/nudged to set up callbacks at the start of a session? (auto-behavior)
- Should there be a way to temporarily disable all callbacks? (e.g. during a big refactor)
- Write tool: should creating a new file also trigger callbacks, or only Edit?

---

## Phase B: Functional Requirements

### Callback Data Model
Each callback has:
- **ID**: auto-generated (CB1, CB2, CB3...)
- **Name**: user-chosen display name (e.g. "rust-check", "pdf-gen")
- **Description**: short explanation of what this callback does
- **Pattern**: gitignore-style positive glob rules (identifies files that trigger this callback). Examples: `*.rs`, `src/**/*.ts`, `seeds/*.yaml`
- **Script**: bash script stored as `.context-pilot/scripts/{name}.sh`
- **Blocking**: bool — whether this callback blocks the Edit/Write tool result
- **Timeout**: max execution time in seconds (required for blocking, optional for non-blocking)
- **Success message**: custom message shown on success (e.g. "Build passed ✓")
- **Working directory**: directory to run the script from (defaults to project root)
- **one_at_a_time**: bool — if true, this callback won't run simultaneously with itself (queued if already running)
- **once_per_batch**: bool — if true, callback fires once per batch with all matched files in $CP_CHANGED_FILES. If false, fires once per matched file.
- **Active/Inactive**: per-worker toggle (stored worker-level). Callback definition is global (config-level).

### Storage
- **Metadata**: stored in `.context-pilot/config.json` (alongside other config)
- **Scripts**: stored as actual bash files in `.context-pilot/scripts/{name}.sh`
- **Worker activation state**: stored per-worker (like module enable/disable)

### Tools (3 tools)

1. **`Callback_upsert`** — Create, update, or delete a callback
   - Param `action`: `create` / `update` / `delete`
   - **Create**: params: name, description, pattern, script_content, blocking, timeout, success_message, cwd, one_at_a_time, once_per_batch. Creates metadata in config + writes script to `.context-pilot/scripts/{name}.sh`. Script gets shebang + env var docs header prepended automatically.
   - **Update**: params: id + any fields to change (name, description, pattern, blocking, timeout, success_message, cwd, one_at_a_time, once_per_batch, script_content). For script content changes, pass full new script_content OR use `old_string`/`new_string` for diff-based editing (requires editor open). If editor not open and diff-edit attempted: returns warning + auto-opens editor.
   - **Delete**: params: id. Removes metadata + deletes script file.
   - New callbacks are active by default for the creating worker.

2. **`Callback_toggle`** — Activate/deactivate callbacks for current worker
   - Params: id, active (bool)
   - Only affects the current worker's activation state
   - Does NOT modify the callback definition

3. **`Callback_open_editor` / `Callback_close_editor`** — Open/close the callback editor
   - Same pattern as `Library_open_prompt_editor` / `Library_close_prompt_editor`
   - Opens the callback's metadata + script content in a panel for viewing/editing
   - Required before diff-based script editing via Callback_upsert(action=update, old_string/new_string)
   - Max one callback open at a time

### Callbacks Panel (always visible)
- Fixed panel in sidebar, always visible (like Library)
- Shows a table overview: ID, Name, Description, Pattern, Blocking, Active/Inactive (for current worker)
- When editor is open: shows full callback details + script content below the table
- Included in LLM context so the AI knows what callbacks exist and which are active

### Trigger Mechanism
- **Edit**, **Write**, and **file deletion** tool calls trigger callback evaluation
- After a batch of parallel tool calls completes:
  1. Collect all changed/created/deleted file paths from the batch
  2. For each active callback, check if any file path matches its pattern
  3. Fire all matching callbacks (parallel in V1)
- **Blocking flow**: all blocking callbacks must finish before ANY tool results are returned to the AI. The batch waits. Each tool result includes its own edit outcome + any callback results that apply to it.
- **Non-blocking flow**: tool results return immediately with a note ("Callback 'xyz' activated in background"). Spawn via console crate, register watcher, notify via spine when done.

---

## Phase C: Non-Functional Requirements & Design

### Architecture: new cp-mod-callback crate
- New module crate: `cp-mod-callback`
- Depends on `cp-base` (Module trait, State, tools, watchers) and `cp-mod-console` (SessionHandle for execution)
- Owns: callback data model, tools, panel, trigger logic, pattern matching, editor

### Storage
- **Metadata**: stored in global `.context-pilot/config.json` (shared across all workers)
- **Scripts**: stored as `.context-pilot/scripts/{name}.sh` (actual bash files, executable)
- **Worker activation state**: stored per-worker in config.json

### Pattern matching: `globset` crate
- Already a workspace dependency (used by cp-mod-tree for tree filter)
- Gitignore-style glob matching: `*.rs`, `src/**/*.ts`, `seeds/*.yaml`
- Fast, well-maintained (ripgrep ecosystem, BurntSushi)
- Zero new dependencies added

### Implementation: bash scripts in .context-pilot/scripts/
- Callbacks are single-file bash scripts stored in `.context-pilot/scripts/`
- The callback rule points to a script + pattern
- Concrete examples for THIS project:
  - `cargo check` after `*.rs` edits
  - `check-file-lengths.sh` after any file edit
  - `check-folder-sizes.sh` after file creation

### Script parametrization: environment variables
- Scripts receive context via env vars, not CLI args
- `$CP_CHANGED_FILES` — newline-separated list of changed file paths (relative to project root)
- `$CP_PROJECT_ROOT` — absolute path to project root
- `$CP_CALLBACK_NAME` — name of the callback rule that triggered
- Script decides what to do with these — could ignore changed files and run `cargo check` on the whole project, or could `rustfmt` only the changed files
- This means any existing script (like `check-file-lengths.sh`) can be used as-is — env vars are additive, not required

### Execution: via console crate
- Scripts are spawned using existing `SessionHandle::spawn()` infrastructure
- Console server manages the process, TUI polls for output
- Blocking callbacks: similar to `easy_bash` pattern (spawn + blocking watcher with timeout)
- Non-blocking callbacks: similar to `console_watch` pattern (spawn + async watcher + spine notification)

### Visibility: panel only on error
- On success (exit code 0): no panel opened. Tool result / notification just says "Callback 'xyz' passed."
- On error (non-zero exit): console panel automatically opened with full output. Tool result / notification shows which edit triggered it, last 3-5 lines of stderr/stdout, and points to the newly opened panel.
- A UUID is always associated with the callback run. The LLM can use this UUID to explicitly open the console panel later if it wants to inspect successful output too. This avoids polluting context with panels the AI doesn't need, while keeping the data accessible.
- This pattern applies to BOTH blocking and non-blocking callbacks.

### Multi-match execution: parallel (v1), job queue (later)
- V1 (first implementation): all matching callbacks run in full parallel. Simple, good enough for 2-3 callbacks.
- Later: implement a job queue managed by the console server. Callback jobs have lower priority than directly-invoked console commands. This is a separate feature — passthrough to all tools/AI, doesn't change the callback contract.

### Other NFR/design signals
- Blocking callbacks need max timeout (guard rail) — same pattern as console_wait
- Non-blocking callbacks appear in Spine panel's Active Watchers section
- Patterns use positive-match (files that DO trigger), not negative-match like gitignore
- File edit still succeeds even if callback fails — callback failure is informational, not fatal
